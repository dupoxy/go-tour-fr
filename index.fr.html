<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
<title>Un Tour de Go</title>
<link href='http://fonts.googleapis.com/css?family=Droid+Serif&v1' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Droid+Sans&v1' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Droid+Sans+Mono&v1' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="static/tour.css" charset="utf-8">
<script src="static/jquery.js"></script>
<script src="static/mode.js"></script>
<script src="static/tour.js"></script>
</head>
<body class="loading">

<h2 id="slidenum"></h2>
<div id="topnav" class="nav">
	<button id="tocbtn">INDEX</button>
</div>

<h1>Un Tour de Go</h1>

<ol id="toc"></ol>

<div id="loading">
	Chargement diapositives ... 
</div>

<div id="slides" class="slides codeleft">

<div class="toc">Bienvenue</div>

<div class="slide">
	<h2>Bonjour, 世界</h2>
	<p>
	Bienvenue à la visite du 
	<a target="_blank" href="http://golang.org/">langage de programmation Go</a>.
	<p>
	Ce tour est divisée en trois sections. A la fin de chaque section il y a une série d'exercices pour vous à compléter.
	<p>
  La visite est interactive. Cliquez sur le bouton Compile maintenant (ou tapez Shift-Entrée) pour compiler et exécuter le programme sur
  <span class="appengineMode">un serveur distant.</span>
  <span class="localMode">votre ordinateur.</span>
  Le résultat est affiché en-dessous du code.
	<p>
	Ces exemples de programmes montrent les différents aspects de Go. Les programmes de ce tour sont censés être des points de départ pour votre propre expérimentation.
	<p>
	Modifier le programme et le relancer.
	<p>
  Chaque fois que vous êtes prêt à passer, cliquez sur le bouton Suivant ou tapez la touche PageDown. 

<div>
package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")
}
</div>
</div>

<div class="slide nocode appengineMode">
	<h2>Go sur votre ordinateur</h2>
	<p>
	Cette visite est également disponible en tant que programme autonome que vous pouvez utiliser sans avoir accès à l'internet.
	<p>
	La visite autonome est plus rapide, car elle construit et gère les exemples de code sur votre propre machine. Elle comprend également des exercices supplémentaires qui ne sont pas disponibles dans cette version sur un serveur distant.
	<p>
	Pour exécuter le tour localement d'abord
	<a target="_blank" href="http://golang.org/doc/install.html">installer Go</a> (la dernière version stable, <code>release.r60.1</code>),
	puis utilisez
	<a target="_blank" href="http://golang.org/cmd/goinstall/">goinstall</a>
	pour installer
	<a target="_blank" href="http://code.google.com/p/go-tour/">gotour</a>:
	<pre>    goinstall go-tour.googlecode.com/hg/gotour</pre>
	<p>
	et lancez l'exécutable <code>gotour</code> résultante.
	<p>
	Sinon, cliquez sur le bouton "suivant" ou tapez PageDown pour continuer.
	<p>
	<i>(Vous pouvez retourner à ces instructions à tout moment en cliquant sur le bouton "Index".)</i>
</div>

<div class="toc">Introduction</div>

<div class="slide">
	<h2>Paquets</h2>
	<p>
	Chaque programme en Go est composée de paquets.
	<p>
	Les programmes commencent l'exécution dans le paquet <code>main</code>.
	<p>
	Ce programme utilise les paquets avec des chemins à l'importation
	<code>"fmt"</code> et <code>"math"</code>.
	<p>
	Par convention, le nom du paquet est le même que le dernier élément du chemin d'importation.
<div>
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println("Happy", math.Pi, "Day")
}
</div>
</div>

<div class="slide">
	<h2>Importations</h2>
	<p>
	Ce code regroupe les importations dans une parenthèse, "factored" import
	statement. Vous pouvez également écrire des instructions à import multiples, comme:
	<pre>
	import "fmt"
	import "math"
	</pre>
	mais il est fréquent d'utiliser la forme factorisée pour éliminer l'encombrement.
<div>
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Printf("Now you have %g problems.",
		math.Nextafter(2, 3))
}
</div>
</div>

<div class="slide">
	<h2>Noms exportés</h2>
	<p>
	Après l'importation d'un paquet, vous pouvez vous référer aux noms qu'il exporte. 
	<p>
	En Go, un nom est exporté s'il commence par une majuscule.
	<p>
	<code>Pi</code> est un nom exporté, comme <code>PI</code>.
	Le nom <code>pi</code> n'est pas exportée.
	<p>
	Exécutez le code. Ensuite, renommez <code>math.pi</code> en <code>math.Pi</code>
	et essayez à nouveau.
<div>
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println(math.pi)
}
</div>
</div>

<div class="slide">
	<h2>Fonctions</h2>
	<p>
	Une fonction peut prendre zéro ou plusieurs arguments.
	<p>
	Dans cet exemple, <code>add</code> prend deux paramètres de type <code>int</code>.

  Notez que le type vient <i>après</i> le nom de variable.
	<p>
	(Pour savoir pourquoi les types ressemblent à ça, voir  <a target="_blank" href="http://blog.golang.org/2010/07/gos-declaration-syntax.html">ce billet de blog</a>.)
<div>
package main

import "fmt"

func add(x int, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}
</div>
</div>

<div class="slide">
	<h2>Fonctions</h2>
	<p>
	Lorsque deux ou plusieurs paramètres consécutifs d'une fonction nommée partagent un même type, vous pouvez omettre le type de tous sauf le dernier.
	<p>
	Dans cet exemple, nous avons raccourci
	<pre>x int, y int</pre>
	<p>
	en
	<pre>x, y int</pre>
<div>
package main

import "fmt"

func add(x, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}
</div>
</div>

<div class="slide">
	<h2>Fonctions</h2>
	<p>
	Une fonction peut retourner n'importe quel nombre de résultats. 
	<p>
	Cette fonction retourne deux chaînes/strings.
<div>
package main

import "fmt"

func swap(x, y string) (string, string) {
	return y, x
}

func main() {
	a, b := swap("hello", "world")
	fmt.Println(a, b)
}
</div>
</div>

<div class="slide">
	<h2>Fonctions</h2>
	<p>
	Les fonctions prennent des paramètres; en Go les résultats peuvent être nommés et agissent comme des variables, qui sont appelés "les paramètres de résultat."
	<p>
	Si les paramètres de résultats sont nommés, une instruction <code>return</code> sans arguments renvoie les valeurs actuelles des résultats. 
<div>
package main

import "fmt"

func split(sum int) (x, y int) {
	x = sum * 4/9
	y = sum - x
	return
}

func main() {
	fmt.Println(split(17))
}
</div>
</div>

<div class="slide">
	<h2>Variables</h2>
	<p>
	L'instruction <code>var</code> déclare une liste de variables;
	comme dans des listes d'arguments de fonction, le type est le dernier.

<div>
package main

import "fmt"

var x, y, z int
var c, python, java bool

func main() {
	fmt.Println(x, y, z, c, python, java)
}
</div>
</div>

<div class="slide">
	<h2>Variables</h2>
	<p>
	Une déclaration de Variables peut inclure des initialisateurs, un par variable.
	<p>
	Si un initialisateur est présent, le type peut être omis; la variable prendra le type de l'initialisateur.
<div>
package main

import "fmt"

var x, y, z int = 1, 2, 3
var c, python, java = true, false, "no!"

func main() {
	fmt.Println(x, y, z, c, python, java)
}
</div>
</div>

<div class="slide">
	<h2>Variables</h2>
	<p>
	A l'intérieur d'une fonction, le <code>:=</code> déclaration courte d'affectation peut être utilisée à la place de la déclaration courte <code>var</code>.
	<p>
	(En dehors d'une fonction, chaque construction commence avec un mot clé,
	<code>:=</code> n'est pas disponible.)
<div>
package main

import "fmt"

func main() {
	var x, y, z int = 1, 2, 3
	c, python, java := true, false, "no!"

	fmt.Println(x, y, z, c, python, java)
}
</div>
</div>

<div class="slide">
	<h2>Constantes</h2>
	<p>
	Les constantes sont déclarées comme des variables, mais avec le mot-clé <code>const</code>
	.
	<p>
	Les constantes peuvent être String, Boolean, ou des valeurs numériques/numeric values.
<div>
package main

import "fmt"

const Pi = 3.14

func main() {
	const World = "世界"
	fmt.Println("Hello", World)
	fmt.Println("Happy", Pi, "Day")

	const Truth = true
	fmt.Println("Go rules?", Truth)
}
</div>
</div>

<div class="slide">
	<h2>Constantes numériques</h2>
	<p>
	Les constantes numériques sont des <i>valeurs</i> de haute précision.
	<p>
	Une constante non typé prend le type selon son contexte.
	<p>
	Essayez avec <code>needInt(Big)</code> aussi.
<div>
package main

import "fmt"

const (
	Big = 1<<100
	Small = Big>>99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
	return x*0.1
}

func main() {
	fmt.Println(needInt(Small))
	fmt.Println(needFloat(Small))
	fmt.Println(needFloat(Big))
}
</div>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	Go a une seule structure de boucle, la boucle <code>for</code>.
	<p>
	L'instruction <code>for</code> ressemble au C ou au Java, sauf que les  <code>( )</code> sont supprimées (elles ne sont même pas en option)
	et les <code>{ }</code> sont obligatoires.
<div>
package main

import "fmt"

func main() {
	sum := 0
	for i := 0; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}
</div>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	Comme en C ou Java, vous pouvez laisser les déclarations pré et post vide.
<div>
package main

import "fmt"

func main() {
	sum := 1
	for ; sum < 1000; {
		sum += sum
	}
	fmt.Println(sum)
}
</div>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	A ce stade, vous pouvez supprimer les points-virgules:
	C's <code>while</code> est orthographié <code>for</code> en Go.
<div>
package main

import "fmt"

func main() {
	sum := 1
	for sum < 1000 {
		sum += sum
	}
	fmt.Println(sum)
}
</div>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	Si vous omettez la condition de boucle, elle boucle indéfiniment. 
<div>
package main

func main() {
	for ; ; {
	}
}
</div>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	Et sans clauses du tout, les points-virgules peut être omis, alors une boucle infinie est compactement exprimé. 
<div>
package main

func main() {
	for {
	}
}
</div>
</div>

<div class="slide">
	<h2>If</h2>
	<p>
	L'instruction <code>if</code> ressemble au C ou au Java, sauf que les  <code>( )</code> sont supprimées (elles ne sont même pas en option)
	et les <code>{ }</code> sont obligatoires.
	<p>
	(Ca vous semble familier?)
<div>
package main

import (
	"fmt"
	"math"
)

func sqrt(x float64) string {
	if x < 0 {
		return sqrt(-x) + "i"
	}
	return fmt.Sprint(math.Sqrt(x))
}

func main() {
	fmt.Println(sqrt(2), sqrt(-4))
}
</div>
</div>

<div class="slide">
	<h2>If</h2>
	<p>
	Comme pour l'instruction <code>for</code>, l'instruction <code>if</code> peut commencer par une courte déclaration à exécuter avant la condition.
	<p>
	Les variables déclarées par la déclaration ne sont que de portée jusqu'à la fin de l'<code>if</code>.
	<p>
	(Essayez d'utiliser <code>v</code> dans la dernier déclaration <code>return</code>.)
<div>
package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	}
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}
</div>
</div>

<div class="slide">
	<h2>If</h2>
	<p>
	Les variables déclarées au sein d'une courte déclaration <code>if</code> sont également disponibles à l'intérieur de l'un des blocs <code>else</code>.
<div>
package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	} else {
		fmt.Printf("%g >= %g\n", v, lim)
	}
	// can't use v here, though
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}
</div>
</div>

<div class="slide">
	<h2>Basic types</h2>
	<p>
	Go's basic types are
	<pre>
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

float32 float64

complex64 complex128
	</pre>
<div>
package main

import (
	"cmath"
	"fmt"
)

var (
	ToBe bool = false
	MaxInt uint64 = 1<<64 - 1
	z complex128 = cmath.Sqrt(-5+12i)
)

func main() {
	const f = "%T(%v)\n"
	fmt.Printf(f, ToBe, ToBe)
	fmt.Printf(f, MaxInt, MaxInt)
	fmt.Printf(f, z, z)
}
</div>
</div>

<div class="slide">
	<h2>Structs</h2>
	<p>
	A <code>struct</code> is a collection of fields.
	<p>
	(And a <code>type</code> declaration does what you'd expect.)
<div>
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	fmt.Println(Vertex{1, 2})
}
</div>
</div>

<div class="slide">
	<h2>Struct Fields</h2>
	<p>
	Struct fields are accessed using a dot.
<div>
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	v := Vertex{1, 2}
	v.X = 4
	fmt.Println(v.X)
}
</div>
</div>

<div class="slide">
	<h2>Pointers</h2>
	<p>
	Go has pointers, but no pointer arithmetic.
	<p>
	Struct fields can be accessed through a struct pointer.
	The indirection through the pointer is transparent.
<div>
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	p := Vertex{1, 2}
	q := &p
	q.X = 1e9
	fmt.Println(p)
}
</div>
</div>

<div class="slide">
	<h2>Struct Literals</h2>
	<p>
	A struct literal denotes a newly allocated struct value by listing the
	values of its fields.
	<p>
	You can list just a subset of fields by using the <code>Name:</code>
	syntax. (And the order of named fields is irrelevant.)
	<p>
	The special prefix <code>&</code> constructs a pointer to a struct
	literal.
<div>
package main

import "fmt"

type Vertex struct {
	X, Y int
}

var (
	p = Vertex{1, 2}  // has type Vertex
	q = &Vertex{1, 2} // has type *Vertex
	r = Vertex{X: 1}  // Y:0 is implicit
	s = Vertex{}      // X:0 and Y:0
)

func main() {
	fmt.Println(p, q, r, s)
}
</div>
</div>

<div class="slide">
	<h2>The <code>new</code> function</h2>
	<p>
	The expression <code>new(T)</code> allocates a zeroed <code>T</code>
	value and returns a pointer to it.
	<pre>var t *T = new(T)</pre>
	<p>
	or
	<pre>t := new(T)</pre>
<div>
package main

import "fmt"

type Vertex struct {
	X, Y int
}

func main() {
	v := new(Vertex)
	fmt.Println(v)
	v.X, v.Y = 11, 9
	fmt.Println(v)
}
</div>
</div>

<div class="slide">
	<h2>Maps</h2>
	<p>
	A map maps keys to values.
	<p>
	<!-- TODO: empty part not true in compilers yet -->
	Maps must be created with <code>make</code> (not <code>new</code>)
	before use; the <code>nil</code> map is empty and cannot be assigned
	to.
<div>
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m map[string]Vertex

func main() {
	m = make(map[string]Vertex)
	m["Bell Labs"] = Vertex{
		40.68433, 74.39967,
	}
	fmt.Println(m["Bell Labs"])
}
</div>
</div>

<div class="slide">
	<h2>Maps</h2>
	<p>
	Map literals are like struct literals, but the keys are required.
<div>
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": Vertex{
		40.68433, -74.39967,
	},
	"Google": Vertex{
		37.42202, -122.08408,
	},
}

func main() {
	fmt.Println(m)
}
</div>
</div>

<div class="slide">
	<h2>Maps</h2>
	<p>
	If the top-level type is just a type name, you can omit it from the
	elements of the literal.
<div>
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": {40.68433, -74.39967},
	"Google":    {37.42202, -122.08408},
}

func main() {
	fmt.Println(m)
}
</div>
</div>

<div class="slide">
	<h2>Slices</h2>
	<p>
	A slice points to an array of values and also includes a length.
	<p>
	<code>[]T</code> is a slice with elements of type <code>T</code>.
<div>
package main

import "fmt"

func main() {
	p := []int{2, 3, 5, 7, 11, 13}
	fmt.Println("p ==", p)

	for i := 0; i < len(p); i++ {
		fmt.Printf("p[%d] == %d\n",
			i, p[i])
	}
}
</div>
</div>

<div class="slide">
	<h2>Slices</h2>
	<p>
	Slices can be re-sliced, creating a new slice value that points to the
	same array.
	<p>
	The expression
	<pre>s[lo:hi]</pre>
	<p>
	evaluates to a slice of the elements from <code>lo</code> through
	<code>hi-1</code>, inclusive. Thus
	<pre>s[lo:lo]</pre>
	<p>
	is empty and
	<pre>s[lo:lo+1]</pre>
	<p>
	has one element.
<div>
package main

import "fmt"

func main() {
	p := []int{2, 3, 5, 7, 11, 13}
	fmt.Println("p ==", p)
	fmt.Println("p[1:4] ==", p[1:4])

	// missing low index implies 0
	fmt.Println("p[:3] ==", p[:3])

	// missing high index implies len(s)
	fmt.Println("p[4:] ==", p[4:])
}
</div>
</div>

<div class="slide">
	<h2>Slices</h2>
	<p>
	Slices are created with the <code>make</code> function. It works by
	allocating a zeroed array and returning a slice that refers to that
	array:
	<pre>
a := make([]int, 5)  // len(a)=5
	</pre>
	Slices have length and capacity. A slice's capacity is the maximum
	length the slice can grow within the underlying array.
	<p>
	To specify a capacity, pass a third argument to <code>make</code>:
	<p>
	<pre>
b := make([]int, 0, 5)
// len(b)=0, cap(b)=5
	</pre>
	Slices can grown by "re-slicing" (up to their capacity):
	<p>
	<pre>
b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4
	</pre>
<div>
package main

import "fmt"

func main() {
	a := make([]int, 5)
	printSlice("a", a)
	b := make([]int, 0, 5)
	printSlice("b", b)
	c := b[:2]
	printSlice("c", c)
	d := c[2:5]
	printSlice("d", d)
}

func printSlice(s string, x []int) {
	fmt.Printf("%s len=%d cap=%d %v\n",
		s, len(x), cap(x), x)
}
</div>
</div>

<div class="slide">
	<h2>Slices</h2>
	<p>
	The zero value of a slice is <code>nil</code>.
	<p>
	A nil slice has a length and capacity of 0.
	<p>
	<i>For more detail see the 
	"<a target="_blank" href="http://blog.golang.org/2011/01/go-slices-usage-and-internals.html">Go Slices: usage and internals</a>"
	article.</i>
<div>
package main

import "fmt"

func main() {
	var z []int
	fmt.Println(z, len(z), cap(z))
	if z == nil {
		fmt.Println("nil!")
	}
}
</div>
</div>

<div class="slide">
	<h2>Functions</h2>
	<p>
	Functions are values too.
<div>
package main

import (
	"fmt"
	"math"
)

func main() {
	hypot := func(x, y float64) float64 {
		return math.Sqrt(x*x + y*y)
	}

	fmt.Println(hypot(3, 4))
}
</div>
</div>

<div class="slide">
	<h2>Functions</h2>
	<p>
	And functions are full closures.
	<p>
	The <code>adder</code> function returns a closure.
	Each closure is bound to its own <code>sum</code> variable.
<div>
package main

import "fmt"

func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	pos, neg := adder(), adder()
	for i := 0; i < 10; i++ {
		fmt.Println(
			pos(i),
			neg(-2*i),
		)
	}
}
</div>
</div>

<div class="slide">
	<h2>Range</h2>
	<p>
	The <code>range</code> form of the <code>for</code>
	loop iterates over a slice or map.
<div>
package main

import "fmt"

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
	for k, v := range pow {
	    fmt.Printf("2**%d = %d\n", k, v)
	}
}
</div>
</div>

<div class="slide">
	<h2>Range</h2>
	<p>
	You can skip the key or value by assigning to <code>_</code>.
	<p>
	If you only want the index, drop the 
	&ldquo;<code>, value</code>&rdquo; entirely.
<div>
package main

import "fmt"

func main() {
	pow := make([]int, 10)
	for i := range pow {
		pow[i] = 1&lt;&lt;uint(i)
	}
	for _, value := range pow {
		fmt.Printf("%d\n", value)
	}
}
</div>
</div>

<div class="slide">
	<h2>Switch</h2>
	<p>
	You probably knew what <code>switch</code> was going to look like.
	<p>
	A case body breaks automatically, unless it ends with a <code>fallthrough</code> statement.

<div>
package main

import (
	"fmt"
	"runtime"
)

func main() {
	fmt.Print("Go runs on ")
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Println("%s.", os)
	}
}
</div>
</div>

<div class="slide">
	<h2>Switch</h2>
	<p>
	Switch cases evaluate cases from top to bottom, stopping when a
	case succeeds.
	<p>
	(For example,
	<pre>
switch i {
case 0:
case f():
}</pre>
	<p>
	does not call <code>f</code> if <code>i==0</code>.)

<div>
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("When's Saturday?")
	today := time.LocalTime().Weekday
	switch time.Saturday {
	case today+0:
		fmt.Println("Today.")
	case today+1:
		fmt.Println("Tomorrow.")
	case today+2:
		fmt.Println("In two days.")
	default:
		fmt.Println("Too far away.")
	}
}
</div>
</div>

<div class="slide">
	<h2>Switch</h2>
	<p>
	Switch without a condition is the same as <code>switch true</code>.

<div>
package main

import (
	"fmt"
	"time"
)

func main() {
	t := time.LocalTime()
	switch {
	case t.Hour < 12:
	    fmt.Println("Good morning!")
	case t.Hour < 17:
	    fmt.Println("Good afternoon.")
	default:
	    fmt.Println("Good evening.")
	}
}
</div>
</div>

<div class="slide">
	<h2>Exercise: Loops and Functions</h2>
	<p>
	As a simple way to play with functions and loops, implement
	the square root function using Newton's method.
	<p>
	In this case, Newton's method is to approximate <code>Sqrt(x)</code>
	by picking a starting point <i>z</i> and then repeating:
	<center>
	<img src="https://chart.googleapis.com/chart?cht=tx&chl=z=z-\frac{z^2-x}{2x}">
	</center>
	<p>
	To begin with, just repeat that calculation 10 times and see how close you
	get to the answer for various values (1, 2, 3, ...).
	<p>
	Next, change the loop condition to stop once the value has stopped changing.
	See if that's more or fewer iterations.
	How close are you to the <a target="_blank" href="http://golang.org/pkg/math/#Sqrt">math.Sqrt</a>?
	<p>
	Hint: to declare and initialize a floating point value, give it
	floating point syntax or use a conversion:
	<pre>
	z := float64(0)
	z := 0.0
	</pre>

<div>
package main

import (
	"fmt"
)

func Sqrt(x float64) float64 {
}

func main() {
	fmt.Println(Sqrt(2))
}
</div>
</div>

<div class="slide">
	<h2>Exercise: Maps</h2>
	<p>
	Implement <code>WordCount</code>.  It should return a map of the
	counts of each &ldquo;word&rdquo; in the string <code>s</code>.
	The <code>wc.Test</code> function runs a test suite against the
	provided function and prints success or failure.
	<p>
	You might find <a target="_blank" href="http://golang.org/pkg/strings/#Fields">strings.Fields</a> helpful.

<div>
package main

import (
	"<span class="appengineMode">tour</span><span class="localMode">go-tour.googlecode.com/hg</span>/wc"
)

func WordCount(s string) map[string]int {
	return map[string]int{"x": 1}
}

func main() {
	wc.Test(WordCount)
}
</div>
</div>

<div class="slide">
	<h2>Exercise: Slices</h2>
	<p>
	Implement <code>Pic</code>. It should return a slice of length
	<code>dy</code>, each element of which is a slice of <code>dx</code>
	8-bit unsigned integers. When you run the program, it will display
	your picture, interpreting the integers as grayscale (well, bluescale)
	values.
	<p>
	The choice of image is up to you.
	Interesting functions include <code>x^y</code>, <code>(x+y)/2</code>, and <code>x*y</code>.
	<p>
	(You need to use a loop to allocate each <code>[]uint8</code> inside
	the <code>[][]uint8</code>.)

<div>
package main

import "<span class="appengineMode">tour</span><span class="localMode">go-tour.googlecode.com/hg</span>/pic"

func Pic(dx, dy int) [][]uint8 {
}

func main() {
	pic.Show(Pic)
}
</div>
</div>

<div class="slide">
	<h2>Exercise: Fibonacci closure</h2>
	<p>
	Let's have some fun with functions.
	<p>
	Implement a <code>fibonacci</code> function that returns a function
	(a closure) that returns successive fibonacci numbers.

<div>
package main

import "fmt"

// fibonacci is a function that returns
// a function that returns an int.
func fibonacci() func() int {
}

func main() {
	f := fibonacci()
	for i := 0; i < 10; i++ {
		fmt.Println(f())
	}
}
</div>
</div>

<div class="slide">
	<h2>Advanced Exercise: Complex cube roots</h2>
	<p>
	Let's explore Go's built-in support for complex numbers via the
	<code>complex64</code> and <code>complex128</code> types.
	For cube roots, Newton's method amounts to repeating:
	<center>
	<img src="https://chart.googleapis.com/chart?cht=tx&chl=z=z-\frac{z^3-x}{3x^2}">
	</center>
	<p>
	Find the cube root of 2, just to make sure the algorithm works.
	There is a <a target="_blank" href="http://golang.org/pkg/cmath/#Pow">cmath.Pow</a> function.

<div>
package main

import "fmt"

func Cbrt(x complex128) complex128 {
}

func main() {
	fmt.Println(Cbrt(2))
}
</div>
</div>


<div class="toc">Methods and Interfaces</div>

<div class="slide nocode">
<h2>Methods and Interfaces</h2>
</div>

<div class="slide">
	<h2>Methods</h2>
	<p>
	Go does not have classes. However, you can define methods on struct
	types.
	<p>
	The <i>method receiver</i> appears in its own argument list
	between the <code>func</code> keyword and the method name.
<div>
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (p *Vertex) Abs() float64 {
	return math.Sqrt(p.X*p.X + p.Y*p.Y)
}

func main() {
	p := &Vertex{3, 4}
	fmt.Println(p.Abs())
}
</div>
</div>

<div class="slide">
	<h2>Methods</h2>
	<p>
	In fact, you can define a method on <i>any</i> type you define in your
	package, not just structs.
	<p>
	You cannot define a method on a type from another package, or on a
	basic type.
<div>
package main

import (
	"fmt"
	"math"
)

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}

func main() {
	f := MyFloat(-math.Sqrt2)
	fmt.Println(f.Abs())
}
</div>
</div>

<div class="slide">
	<h2>Methods with pointer receivers</h2>
	<p>
	Methods can be associated with a named type or a pointer
	to a named type.
	<p>
	We just saw two <code>Abs</code> methods. One on the
	<code>*Vertex</code> pointer type and the other on the
	<code>MyFloat</code> value type.
	<p>
	There are two reasons to use a pointer receiver.
	First, to avoid copying the value on each method call (more efficient
	if the value type is a large struct). Second, so that the method can
	modify the value that its receiver points to.
	</ol>
	<p>
	Try changing the declarations of the <code>Abs</code> and
	<code>Scale</code> methods to use <code>Vertex</code> as the
	receiver, instead of <code>*Vertex</code>.
	<p>
	The <code>Scale</code> method has no effect when <code>v</code> is a
	<code>Vertex</code>. <code>Scale</code> mutates <code>v</code>. When
	<code>v</code> is a value (non-pointer) type, the method sees a copy of
	the <code>Vertex</code> and cannot mutate the original value.
	<p>
	<code>Abs</code> works either way. It only reads <code>v</code>.
	It doesn't matter whether it is reading the original value (through a
	pointer) or a copy of that value.
<div>
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (p *Vertex) Scale(f float64) {
	p.X = p.X * f
	p.Y = p.Y * f
}

func (p *Vertex) Abs() float64 {
	return math.Sqrt(p.X*p.X + p.Y*p.Y)
}

func main() {
	p := &Vertex{3, 4}
	p.Scale(5)
	fmt.Println(p, p.Abs())
}
</div>
</div>

<div class="slide">
	<h2>Interfaces</h2>
	<p>
	An interface type is defined by a set of methods.
	<p>
	A value of interface type can hold any value that
	implements those methods.

<div>
package main

import (
	"fmt"
	"math"
)

type Abser interface {
	Abs() float64
}

func main() {
	var a Abser
	f := MyFloat(-math.Sqrt2)
	p := Vertex{3, 4}

	a = f  // a MyFloat implements Abser
	a = &p // a *Vertex implements Abser
	a = p  // a Vertex, does NOT
	       // implement Abser

	fmt.Println(a.Abs())
}

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}

type Vertex struct {
	X, Y float64
}

func (p *Vertex) Abs() float64 {
	return math.Sqrt(p.X*p.X + p.Y*p.Y)
}
</div>
</div>

<div class="slide">
	<h2>Interfaces</h2>
	<p>
	A type implements an interface by implementing the methods.
	<p>
	<i>There is no explicit declaration of intent.</i>
	<p>
	Implicit interfaces decouple implementation packages from the packages
	that define the interfaces: neither depends on the other.
	<p>
	It also encourages the definition of precise interfaces, because you
	don't have to find every implementation and tag it with the new
	interface name.
	<p>
	<a target="_blank" href="http://golang.org/pkg/io/">Package io</a> defines <code>Reader</code> and <code>Writer</code>; you don't have to.
<div>
package main

import (
	"fmt"
	"os"
)

type Reader interface {
	Read(b []byte) (n int, err os.Error)
}

type Writer interface {
	Write(b []byte) (n int, err os.Error)
}

type ReadWriter interface {
	Reader
	Writer
}

func main() {
	var w Writer

	// os.Stdout implements Writer
	w = os.Stdout

	fmt.Fprintf(w, "hello, writer\n")
}
</div>
</div>

<div class="slide">
	<h2>Errors</h2>
	<p>
	An error is anything that can describe itself:
	<pre>
package os

type Error interface {
	String() string
}
	</pre>

<div>
package main

import (
	"fmt"
	"os"
	"time"
)

type MyError struct {
	When *time.Time
	What string
}

func (e *MyError) String() string {
	return fmt.Sprintf("at %v, %s",
		e.When, e.What)
}

func run() os.Error {
	return &MyError{
		time.LocalTime(),
		"it didn't work",
	}
}

func main() {
	if err := run(); err != nil {
		fmt.Println(err)
	}
}
</div>
</div>

<div class="slide">
	<h2>Web servers</h2>
	<p>
	<a target="_blank" href="http://golang.org/pkg/http/">Package http</a> serves HTTP requests using any value
	that implements <code>http.Handler</code>:
	<pre>
package http

type Handler interface {
	ServeHTTP(w ResponseWriter,
	          r *Request)
}
	</pre>
	<p>
	In this example, the type <code>MyHandler</code> implements <code>http.Handler</code>.
	<p>
	<span class="localMode">
	Visit <a href="http://localhost:4000/" target="_blank">http://localhost:4000/</a> to see the greeting.
	</span>
	<span class="appengineMode">
	<b>Note:</b> This example won't run through the web-based tour user
	interface. To try writing web servers you may want to
	<a target="_blank" href="http://golang.org/doc/install.html">Install
	Go</a>.
	</span>
<div>
package main

import (
	"fmt"
	"http"
)

type Hello struct{}

func (h Hello) ServeHTTP(
		w http.ResponseWriter,
		r *http.Request) {
	fmt.Fprint(w, "Hello!")
}

func main() {
	var h Hello
	http.ListenAndServe("localhost:4000",h)
}
</div>
</div>

<div class="slide">
	<h2>Images</h2>
	<p>
	<a target="_blank" href="http://golang.org/pkg/image/#Image">Package image</a> defines the <code>Image</code>
	interface:
	<pre>
package image

type Image interface {
	ColorModel() ColorModel
	Bounds() Rectangle
	At(x, y int) Color
}</pre>
	<p>
	(See <a target="_blank" href="http://golang.org/pkg/image/#Image">the
	documentation</a> for all the details.)
	<p>
	<code>Color</code> and <code>ColorModel</code> are interfaces too,
	but we'll ignore that by using the predefined implementations
	<code>image.RGBAColor</code> and <code>image.RGBAColorModel</code>.

<div>
package main

import (
	"fmt"
	"image"
)

func main() {
	m := image.NewRGBA(100, 100)
	fmt.Println(m.Bounds())
	fmt.Println(m.At(0, 0).RGBA())
}
</div>
</div>

<div class="slide">
	<h2>Exercise: Errors</h2>
	<p>
	Copy your <code>Sqrt</code> function from the earlier exercises and
	modify it to return an <code>os.Error</code> value.
	<p>
	<code>Sqrt</code> should return a non-nil error value when given a
	negative number, as it doesn't support complex numbers.
	<p>
	Create a new type
	<pre>
type ErrNegativeSqrt float64</pre>
	<p>
	and make it an <code>os.Error</code> by giving it a 
	<pre>
func (e ErrNegativeSqrt) String() string</pre>
	<p>
	method such that <code>ErrNegativeSqrt(-2).String()</code> returns
	<code>"cannot Sqrt negative number: -2"</code>.
	<p>
	<b>Note:</b> a call to <code>fmt.Print(e)</code> inside the
	<code>String</code> method will send the program into an infinite loop.
	You can avoid this by converting <code>e</code> first:
	<code>fmt.Print(float64(e))</code>. Why?
	<p>
	Change your <code>Sqrt</code> function to return an
	<code>ErrNegativeSqrt</code> value when given a negative number.
<div>
package main

import (
	"fmt"
	"os"
)

func Sqrt(f float64) (float64, os.Error) {
	return 0, nil
}

func main() {
	fmt.Println(Sqrt(2))
	fmt.Println(Sqrt(-2))
}
</div>
</div>

<div class="slide localMode">
	<h2>Exercise: HTTP Handlers</h2>
	<p>
	Implement the following types and define ServeHTTP methods on them.
	Register them to handle specific paths in your web server.
<pre>type String string
	
type Struct struct {
	Greeting string
	Punct    string
	Who      string
}</pre>
	<p>
	For example, you should be able to register handlers using:
<pre>http.Handle("/string", String("I'm a frayed knot."))
http.Handle("/struct", &Struct{"Hello", ":", "Gophers!"})</pre>
<div>
package main

import (
	"http"
)

func main() {
	// your http.Handle calls here
	http.ListenAndServe("localhost:4000", nil)
}
</div>
</div>

<div class="slide">
	<h2>Exercise: Images</h2>
	<p>
	Remember the picture generator you wrote earlier?
	Let's write another one, but this time it will return
	an implementation of <code>image.Image</code> instead of a slice of data.
	<p>
	Define your own <code>Image</code> type, implement
	<a target="_blank" href="http://golang.org/pkg/image/#Image" target="_blank">the necessary methods</a>,
	and call <code>pic.ShowImage</code>.
	<p>
	<code>Bounds</code> should return a <code>image.Rectangle</code>, like
	<code>image.Rect(0, 0, w, h)</code>.
	<p>
	<code>ColorModel</code> should return <code>image.RGBAColorModel</code>.
	<p>
	<code>At</code> should return a color;
	the value <code>v</code> in the last picture generator corresponds to
	<code>image.RGBAColor{v, v, 255, 255}</code> in this one.

<div>
package main

import (
	"image"
	"<span class="appengineMode">tour</span><span class="localMode">go-tour.googlecode.com/hg</span>/pic"
)

type Image struct{}

func main() {
	m := Image{}
	pic.ShowImage(m)
}
</div>
</div>

<div class="slide">
	<h2>Exercise: Rot13 Reader</h2>
	<p>
	A common pattern is an
	<a target="_blank" href="http://golang.org/pkg/io/#Reader">io.Reader</a> that wraps
	another <code>io.Reader</code>, modifying the stream in some way.
	<p>
	For example, the
	<a target="_blank" href="http://golang.org/pkg/compress/gzip/#Decompressor.NewReader">gzip.NewReader</a>
	function takes an <code>io.Reader</code> (a stream of gzipped data)
	and returns a <code>*gzip.Decompressor</code> that also implements
	<code>io.Reader</code> (a stream of the decompressed data).
	<p>
	Implement a <code>rot13Reader</code> that implements
	<code>io.Reader</code> and reads from an <code>io.Reader</code>,
	modifying the stream by applying the
	<a target="_blank" href="http://en.wikipedia.org/wiki/ROT13">ROT13</a>
	substitution cipher to all alphabetical characters.
	<p>
	The <code>rot13Reader</code> type is provided for you.  Make it an
	<code>io.Reader</code> by implementing its <code>Read</code> method.
<div>
package main

import (
	"io"
	"os"
	"strings"
)

type rot13Reader struct {
	r io.Reader
}

func main() {
	s := strings.NewReader(
		"Lbh penpxrq gur pbqr!")
	r := rot13Reader{s}
	io.Copy(os.Stdout, &r)
}
</div>
</div>

<div class="toc">Concurrency</div>

<div class="slide nocode">
<h2>Concurrency</h2>
</div>

<div class="slide">
	<h2>Goroutines</h2>
	<p>
	A <i>goroutine</i> is a lightweight thread managed by the Go runtime.
	<pre>go f(x, y, z)</pre>
	<p>
	starts a new goroutine running
	<pre>f(x, y, z)</pre>
	<p>
	The evaluation
        of <code>f</code>, <code>x</code>, <code>y</code>, and <code>z</code>
        happens in the current goroutine and the execution of <code>f</code>
	happens in the new goroutine.
	<p>
	Goroutines run in the same address space, so access to shared memory
	must be synchronized. The <code><a href="http://golang.org/pkg/sync/"
	target="_blank">sync</a></code> package provides useful primitives,
	although you won't need them much in Go as there are other primitives.
	(See the next slide.)
<div>
package main

import (
	"fmt"
	"<span class="appengineMode">runtime</span><span class="localMode">time</span>"
)

func say(s string) {
	for i := 0; i < 5; i++ {
		<span class="appengineMode">runtime.Gosched()</span><span class="localMode">time.Sleep(100e6)</span>
		fmt.Println(s)
	}
}

func main() {
	go say("world")
	say("hello")
}
</div>
</div>

<div class="slide">
	<h2>Channels</h2>

	<p>
	Channels are a typed conduit through which you can send and receive values with the channel operator, <code>&lt;-</code>.
<pre>
ch <- v    // Send v to channel ch.
v := <-ch  // Receive from ch, and
           // assign value to v.
</pre>
	<p>
	(The data flows in the direction of the "arrow".)

	<p>
	Like maps and slices, channels must be created before use:
<pre>
ch := make(chan int)
</pre>

	<p>
	By default, sends and receives block until the other side is ready.
	This allows goroutines to synchronize without explicit locks or
	condition variables.
<div>
package main

import "fmt"

func sum(a []int, c chan int) {
	sum := 0
	for _, v := range a {
		sum += v
	}
	c <- sum  // send sum to c
}

func main() {
	a := []int{7, 2, 8, -9, 4, 0}

        c := make(chan int)
	go sum(a[:len(a)/2], c)
	go sum(a[len(a)/2:], c)
        x, y := <-c, <-c  // receive from c

	fmt.Println(x, y, x + y)
}
</div>
</div>


<div class="slide">
	<h2>Buffered Channels</h2>
	
	<p>
	Channels can be <i>buffered</i>.  Provide the buffer length as the
	second argument to <code>make</code> to initialize a buffered channel:
<pre>
ch := make(chan int, 100)
</pre>

	<p>
	Sends to a buffered channel block only when the buffer is full.
	Receives block when the buffer is empty.

	<p>
	Modify the example to overfill the buffer and see what happens.

<div>
package main

import "fmt"

func main() {
	c := make(chan int, 2)
	c <- 1
	c <- 2
	fmt.Println(<-c)
	fmt.Println(<-c)
}
</div>
</div>

<div class="slide">
	<h2>Range and Close</h2>
	<p>
	A sender can <code>close</code> a channel to indicate that no more
	values will be sent. Receivers can test whether a channel has been
	closed by assigning a second parameter to the receive expression: after
	<pre>
v, ok := &lt;-ch</pre>
	<p>
	<code>ok</code> is <code>false</code> if there are no more values to
	receive and the channel is closed.
	<p>
	The loop <code>for i := range c</code> receives values from the
	channel repeatedly until it is closed.
	<p>
	<b>Note:</b> Only the sender should close a channel, never the
	receiver. Sending on a closed channel will cause a panic.
	<p>
	<b>Another note</b>: Channels aren't like files; you don't usually
	need to close them. Closing is only necessary when the receiver must be
	told there are no more values coming.
<div>
package main

import (
	"fmt"
)

func fibonacci(n int, c chan int) {
        x, y := 1, 1
        for i := 0; i < n; i++ {
                c <- x
                x, y = y, x + y
        }
        close(c)
}

func main() {
        c := make(chan int, 10)
	go fibonacci(cap(c), c)
        for i := range c {
                fmt.Println(i)
        }
}
</div>
</div>

<div class="slide">
	<h2>Select</h2>
	<p>
	The <code>select</code> statement lets a goroutine wait on multiple
	communication operations.
	<p>
	A <code>select</code> blocks until one of its cases can run, then it
	executes that case.  It chooses one at random if multiple are ready.
<div>
package main

import "fmt"

func fibonacci(c, quit chan int) {
        x, y := 1, 1
        for {
                select {
                case c <- x:
                          x, y = y, x + y
                case <-quit:
			fmt.Println("quit")
                        return
                }
        }
}

func main() {
        c := make(chan int)
	quit := make(chan int)
	go func() {
		for i := 0; i < 10; i++ {
			fmt.Println(<-c)
		}
		quit <- 0
	}()
	fibonacci(c, quit)
}
</div>
</div>

<div class="slide">
	<h2>Default Selection</h2>
	<p>
	The <code>default</code> case in a <code>select</code> is run if no
	other case is ready.
	<p>
	Use a <code>default</code> case to try a send or receive without
	blocking:
	<pre>
select {
case i := <-c:
	// use i
default:
	// receiving from c would block
}</pre>
	<p>
	<span class="appengineMode">
	<b>Note:</b> This example won't run through the web-based tour user
	interface because the
	<a target="_blank" href="http://golang.org/doc/play/">sandbox
	environment</a> has no concept of time. You may want to
	<a target="_blank" href="http://golang.org/doc/install.html">install
	Go</a> to see this example in action.
	</span>
<div>
package main

import (
	"fmt"
	"time"
)

func main() {
        tick := time.Tick(1e8)
        boom := time.After(5e8)
        for {
                select {
                case <-tick:
                        fmt.Println("tick.")
                case <-boom:
                        fmt.Println("BOOM!")
                        return
                default:
                        fmt.Println("    .")
                        time.Sleep(5e7)
                }
        }
}
</div>
</div>

<div class="slide nocode">
	<h2>Exercise: Equivalent Binary Trees</h2>
	<p>
	There can be many different binary trees with the same sequence of
	values stored at the leaves.
	For example, here are two binary trees storing the sequence
	1, 1, 2, 3, 5, 8, 13.
	<img src="static/fig4.png">
	<p>
	A function to check whether two binary trees store the same sequence is
	quite complex in most languages. We'll use Go's concurrency and
	channels to write a simple solution.
	<p>
	This example uses the <code>tree</code> package, which defines the type:
<pre>
type Tree struct {
	Left  *Tree
	Value int
	Right *Tree
}
</pre>
</div>

<div class="slide">
	<h2>Exercise: Equivalent Binary Trees</h2>
	<p>
	<b>1.</b> Implement the <code>Walk</code> function.
	<p>
	<b>2.</b> Test the <code>Walk</code> function.
	<p>
	The function <code>tree.New(k)</code> constructs a randomly-structured
	binary tree holding the values <code>k</code>, <code>2k</code>, <code>3k</code>, ...,
	<code>10k</code>.
	<p>
	Create a new channel <code>ch</code> and kick off the walker:
<pre>
go Walk(tree.New(1), ch)
</pre>
	<p>
	Then read and print 10 values from the channel.
	It should be the numbers 1, 2, 3, ..., 10.
	<p>
	<b>3.</b> Implement the <code>Same</code> function using <code>Walk</code>
	to determine whether <code>t1</code> and <code>t2</code> store the same values.
	<p>
	<b>4.</b> Test the <code>Same</code> function. 
	<p>
	<code>Same(tree.New(1), tree.New(1))</code> should return true, and
	<code>Same(tree.New(1), tree.New(2))</code> should return false.

<div>
package main

import "<span class="appengineMode">tour</span><span class="localMode">go-tour.googlecode.com/hg</span>/tree"

// Walk walks the tree t sending all values
// from the tree to the channel ch.
func Walk(t *tree.Tree, ch chan int)

// Same determines whether the trees
// t1 and t2 contain the same values.
func Same(t1, t2 *tree.Tree) bool

func main() {
}
</div>
</div>

<div class="slide">
	<h2>Exercise: Web Crawler</h2>
	<p>
	In this exercise you'll use Go's concurrency features to
	parallelize a web crawler.
	<p>
	Modify the <code>Crawl</code> function to fetch URLs in parallel
	without fetching the same URL twice.
<div>
package main

import (
	"os"
	"fmt"
)

type Fetcher interface {
	// Fetch returns the body of URL and
	// a slice of URLs found on that page.
	Fetch(url string) (body string, urls []string, err os.Error)
}

// Crawl uses fetcher to recursively crawl
// pages starting with url, to a maximum of depth.
func Crawl(url string, depth int, fetcher Fetcher) {
	// TODO: Fetch URLs in parallel.
	// TODO: Don't fetch the same URL twice.
	// This implementation doesn't do either:
	if depth <= 0 {
		return
	}
	body, urls, err := fetcher.Fetch(url)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("found: %s %q\n", url, body)
	for _, u := range urls {
		Crawl(u, depth-1, fetcher)
	}
	return
}

func main() {
	Crawl("http://golang.org/", 4, fetcher)
}


// fakeFetcher is Fetcher that returns canned results.
type fakeFetcher map[string]*fakeResult

type fakeResult struct {
	body string
	urls     []string
}

func (f *fakeFetcher) Fetch(url string) (string, []string, os.Error) {
	if res, ok := (*f)[url]; ok {
		return res.body, res.urls, nil
	}
	return "", nil, fmt.Errorf("not found: %s", url)
}

// fetcher is a populated fakeFetcher.
var fetcher = &fakeFetcher{
	"http://golang.org/": &fakeResult{
		"The Go Programming Language",
		[]string{
			"http://golang.org/pkg/",
			"http://golang.org/cmd/",
		},
	},
	"http://golang.org/pkg/": &fakeResult{
		"Packages",
		[]string{
			"http://golang.org/",
			"http://golang.org/cmd/",
			"http://golang.org/pkg/fmt/",
			"http://golang.org/pkg/os/",
		},
	},
	"http://golang.org/pkg/fmt/": &fakeResult{
		"Package fmt",
		[]string{
			"http://golang.org/",
			"http://golang.org/pkg/",
		},
	},
	"http://golang.org/pkg/os/": &fakeResult{
		"Package os",
		[]string{
			"http://golang.org/",
			"http://golang.org/pkg/",
		},
	},
}
</div>
</div>

<div class="slide nocode">
	<h2>Where to Go from here...</h2>
	<p class="appengineMode">
	You can get started by
	<a href="http://golang.org/doc/install.html">installing Go</a> or
	downloading the
	<a href="http://code.google.com/appengine/downloads.html#Google_App_Engine_SDK_for_Go">Go App Engine SDK</a>.
	</p>
	<p>
	<span class="appengineMode">Once you have Go on your machine, the</span>
	<span class="localMode">The</span>
	<a target="_blank" href="http://golang.org/doc/docs.html">Go Documentation</a>
	is a great place to
	<span class="appengineMode">continue</span>
	<span class="localMode">start</span>.
	It contains references, tutorials, videos, and more.
	<p>
	If you need help with the standard library,
	see the <a target="_blank" href="http://golang.org/pkg/">package
	reference</a>.  For help with the language itself, you might be
	surprised to find the
	<a target="_blank" href="http://golang.org/doc/go_spec.html">Language
	Spec</a> is quite readable.
	<p>
	If you're interested in writing web applications,
	see the
	<a target="_blank" href="http://golang.org/doc/codelab/wiki/">Wiki
	Codelab</a>.
	<p>
	If you want to further explore Go's concurrency model, see the
	<a target="_blank" href="http://golang.org/doc/codewalk/sharemem/">Share Memory by Communicating</a>
	codewalk.
	<p>
	The <a target="_blank" href="http://golang.org/doc/codewalk/functions/">First Class Functions in Go</a>
	codewalk gives an interesting perspective on Go's function types.
	<p>
	The <a target="_blank" href="http://blog.golang.org/">Go Blog</a> has a
	large archive of informative Go articles.
	<p>
	Visit <a target="_blank" href="http://golang.org">golang.org</a> for
	more.
</div>

</div><!-- end slides -->

</body>
</html>

