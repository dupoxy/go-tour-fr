Méthodes et interfaces
Cette leçon couvre les méthodes et les interfaces, les constructions qui définissent des objets et leur comportement.

Les auteurs de Go
http://golang.org

* Méthodes

Go n'a pas  de classes. Cependant, vous pouvez définir des méthodes sur les types struct.

Le _method_receiver_ apparaît dans sa propre liste d'arguments entre le mot clé `func` et le nom de la méthode.

.play prog/tour/methods.go

* Méthodes continué

En fait, vous pouvez définir une méthode sur _tout_  type que vous définissez dans votre paquet, et pas seulement sur les structures.

Vous ne pouvez pas définir une méthode sur un type d'un autre paquet, ou sur un type de base.

.play prog/tour/methods-continued.go

* Méthodes avec des récepteurs de pointeur

Les méthodes peuvent être associées à un type nommé ou un pointeur vers un type nommé.

Nous venons de voir deux méthodes `Abs`. Un sur le `*Vertex` type pointeur et l'autre sur le `MyFloat` type valeur.

Il y a deux raisons d'utiliser un récepteur de pointeur. Tout d'abord, pour éviter de copier la valeur à chaque appel de la méthode (plus efficace si le type de valeur est une grande struct). En second lieu, de sorte que le procédé peut modifier la valeur de ce que sa pointe vers le récepteur.

Essayez de modifier les déclarations des méthodes `Abs` et `Scale`  en utilisant `Vertex` comme récepteur, au lieu de `*Vertex`.

La méthode `Scale` n'a aucun effet lorsque `v` est un `Vertex`. `Scale` mutates `v`. Lorsque `v` est de type d'une valeur  (non-pointeur), la méthode voit une copie de `Vertex` et ne peut pas muter la valeur d'origine.

`Abs` fonctionne de toute façon. Elle lit que `v`. Ce n'est pas grave si elle est en train de lire la valeur d'origine (via un pointeur) ou une copie de cette valeur.

.play prog/tour/methods-with-pointer-receivers.go

* Interfaces

Un type d'interface est définie par un ensemble de méthodes.

Une valeur de type d'interface peut contenir n'importe quelle valeur qui implémente ces méthodes.

*Note:* Ce code ne se compile pas.

`Vertex` ne satisfait pas `Abser` car
la method `Abs` est seulemnt defini sur `*Vertex`, et non pas `Vertex`.

.play prog/tour/interfaces.go

* Les interfaces sont satisfaits implicitement

Un type implémente une interface en mettant en œuvre les méthodes.

_There_is_no_explicit_declaration_of_intent._

Les interfaces implicites découple les paquets d'implementation des paquets qui définissent les interfaces: aucun ne dépend de l'autre.

Il encourage également la définition précises des interfaces, parce que vous n'avez pas à trouver chaque mise en œuvre et l'étiqueter avec le nom de la nouvelle interface.

[[http://golang.org/pkg/io/][le Paquet io]] definis `Reader` et `Writer`; pour vous.

.play prog/tour/interfaces-are-satisfied-implicitly.go

* Erreurs

Une erreur et tout ce qui peut se décrire comme une chaîne d'erreur. L'idée est capturée par la type d'interface prédéfinie, `error`, avec sa méthode unique, `Error`, retournant une chaîne:

	type error interface {
		Error() string
	}

Les diverses routines d'impression du paquet `fmt` savent appeler automatiquement la méthode lorsqu'on lui demande d'imprimer une `error`.

.play prog/tour/errors.go

* Exercice: erreurs

Copiez la fonction de votre `Sqrt` des exercices antérieurs et la modifier pour retourner une valeur `error`.

`Sqrt` doit retourner une valeur d'erreur non-nulle quand on lui donne un nombre négatif, car il ne supporte pas les nombres complexes.

Créer un nouveau type

	type ErrNegativeSqrt float64

et en faire une `error` en lui donnant une

	func (e ErrNegativeSqrt) Error() string

méthode telle que `ErrNegativeSqrt(-2).Error()` renvoie `"cannot`Sqrt`negative`number:`-2"`.

*Note:* un appel à `fmt.Print(e)` à l'intérieur de la méthode `Error` enverra le programme dans une boucle infinie. Vous pouvez éviter cela en convertissant `e` en premier: `fmt.Print(float64(e))`. Pourquoi?

Changer la fonction `Sqrt` pour retourner une valeur `ErrNegativeSqrt` quand donné un nombre négatif.

.play prog/tour/exercise-errors.go

* Serveurs Web

[[http://golang.org/pkg/net/http/][Paquet http]] sert les requêtes HTTP à l'aide de n'importe quelle valeur qui implémente `http.Handler`:

	package http
	
	type Handler interface {
		ServeHTTP(w ResponseWriter, r *Request)
	}

Dans cet exemple, le type `Hello` implémente `http.Handler`.

Visitez [[http://localhost:4000/][http://localhost:4000/]] pour voir l'annonce.

#appengine: *Note:* Cet exemple ne fonctionnera pas si le tour est sur le Web
#appengine: interface. Pour essayer d'écrire des serveurs Web vous souhaiterez peut-être
#appengine: [[http://golang.org/doc/install/][Installer Go]].

.play prog/tour/web-servers.go

* Exercice: gestionnaires HTTP

Mettre en œuvre les types suivants et définir des méthodes ServeHTTP sur eux. Inscrivez-vous pour gérer des chemins spécifiques à votre serveur web.

	type String string
	
	type Struct struct {
		Greeting string
		Punct    string
		Who      string
	}

Par exemple, vous devriez être capable d'enregistrer des gestionnaires à l'aide de:

	http.Handle("/string", String("I'm a frayed knot."))
	http.Handle("/struct", &Struct{"Hello", ":", "Gophers!"})

.play prog/tour/exercise-http-handlers.go

* Images

[[http://golang.org/pkg/image/#Image][Package image]] définit l'interface `Image`:

	package image
	
	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

(Voir [[http://golang.org/pkg/image/#Image][la documentation]] pour tous les détails.)

En outre, `color.Color` et `color.Model` sont des interfaces, mais nous allons ignorer ça en utilisant les implémentations prédéfinies `color.RGBA` et `color.RGBAModel`. Ces interfaces et types sont spécifiés par le paquet [[http://golang.org/pkg/image/color/][image/color]]

.play prog/tour/images.go

* Exercice: Images

Souvenez-vous du générateur d'images que vous avez écrit plus tôt? Écrivons un autre, mais cette fois, il retournera une implémentation de `image.Image` au lieu d'une tranche de données.

Définissez votre propre type `Image`, mettre en œuvre [[http://golang.org/pkg/image/#Image][les méthodes nécessaires]], et appeler `pic.ShowImage`.

`Bounds` devraient retourner un `image.Rect(0,`0,`w,`h)`.

`ColorModel` doit retourner `color.RGBAModel`.

`At` doit retourner une couleur, la valeur `v` au dernier générateur d'image correspond à `color.RGBA{v,`v,`255,`255}` dans celui-ci.

.play prog/tour/exercise-images.go

* Exercice: lecteur Rot13

Un modèle commun est un [[http://golang.org/pkg/io/#Reader][io.Reader]] qui enveloppe un autre `io.Reader`, en modifiant le flux d'une certaine façon.

Par exemple, la fonction [[http://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]] prend un `io.Reader` (un flux de données gzip) et renvoie un `*gzip.Reader` qui implémente également `io.Reader`(un flux des données décompressées).

Mettre en place un `rot13Reader` qui implémente `io.Reader` et lit d'un `io.Reader`, modifiant le flux en appliquant le [[http://en.wikipedia.org/wiki/ROT13][ROT13]] substitution chiffrement à tous les caractères alphabétiques.

Le type `rot13Reader` est fourni pour vous. Faites-en un `io.Reader` en mettant en œuvre sa méthode `Read`.

.play prog/tour/exercise-rot-reader.go

* Félicitations!

Vous avez terminé cette leçon!

Vous pouvez revenir à la liste des [[/list][modules]] pour trouver ce qu'il faut apprendre à côté, ou continuer avec la [[javascript:click('.next-page')][Leçon suivante]]. lesson]].
