Instructions de contrôle du flux : for, if, else, switch et defer
Apprenez à contrôler le flux de votre code avec les conditionnels, boucles, commutateurs et defers.

Les auteurs de Go
https://golang.org

* For

Go a une seule structure de boucle, la boucle `for`.

La boucle de base `for` a trois composantes séparées par des points-virgules :

- l'initialisation : exécutée avant la première itération
- la condition : évaluée avant chaque itération
- l'aboutissement : exécutée à la fin de chaque itération.

L'initialisation sera souvent une déclaration de variable courte et les
variables ainsi déclarées ne sont visibles que dans le cadre de la déclaration
`for`.

L'itération de la boucle s'arrêtera une fois que la condition (booléen) sera évaluée à `false`.

*Note*:* contrairement à d'autres langages comme C, Java ou JavaScript, il n'y a pas de parenthèses
entourant les trois composantes de la déclaration `for` et les accolades `{`}` sont
toujours obligatoires.

.play flowcontrol/for.go

* For (suite)

La déclaration d'initialisation et d'aboutissement sont facultatifs.

.play flowcontrol/for-continued.go

* For est le « while » de Go

À ce stade, vous pouvez oublier les points-virgules : le `while` de C est orthographié `for` en Go.

.play flowcontrol/for-is-gos-while.go

* Infini

Si vous omettez la condition de la boucle, elle boucle à l'infini, donc une boucle infinie s'écrit concisément.

.play flowcontrol/forever.go

* If

La déclaration `if` de Go ressemble à la boucle `for` : l'expression n'a pas besoin d'être
entourée par des parenthèses `(`)` mais les accolades `{`}` sont obligatoires.

.play flowcontrol/if.go

* If avec une déclaration courte

Comme `for`, l'instruction `if` peut commencer par une brève déclaration à exécuter avant la condition.

Les variables déclarées dans la déclaration ont seulement une portée jusqu'à la fin du `if`.

(Essayez d'utiliser `v` lors de la dernière instruction `return`.)

.play flowcontrol/if-with-a-short-statement.go

* If et else

Les variables déclarées dans une instruction courte `if` sont également disponibles dans
n'importe lequel des blocs `else`.

(Les deux appels à `pow` retournent leurs résultats avant que l'appel à `fmt.Println`
dans `main` ne commence.)
 
.play flowcontrol/if-and-else.go

* Exercice : les boucles et les fonctions

Pour jouer avec les fonctions et les boucles, implémentons une fonction racine carrée : étant donné un nombre x, nous voulons trouver le nombre z pour lequel z² est le plus proche de x.

Les ordinateurs calculent généralement la racine carrée de x à l'aide d'une boucle.
En commençant par une supposition z, nous pouvons ajuster z en fonction de la proximité de z² à x,
pour produire une meilleure estimation :

	z -= (z*z - x) / (2*z)

La répétition de cet ajustement rend la supposition de mieux en mieux
jusqu'à ce que nous arrivions à une réponse aussi proche que possible de la racine carrée réelle.

Implémentez ceci dans la `func`Sqrt` fournie.
Une estimation de départ décente pour z est 1, quelle que soit l'entrée.
Pour commencer, répétez le calcul 10 fois et imprimez chaque z en cours de route.
Voyez à quel point vous vous rapprochez de la réponse pour différentes valeurs de x (1, 2, 3, …)
et à quelle vitesse la supposition s'améliore.

Astuce : pour déclarer et initialiser une valeur à virgule flottante,
donnez-lui une syntaxe à virgule flottante ou utilisez une conversion :

	z := 1.0
	z := float64(1)

Ensuite, modifiez la condition de boucle pour qu'elle s'arrête une fois que la valeur a cessé de
changer (ou ne change que très peu).
Voyez si c'est plus ou moins de 10 itérations.
Essayez d'autres suppositions initiales pour z, comme x, ou x/2.
Dans quelle mesure les résultats de votre fonction sont-ils proches de ceux de la fonction [[https://golang.org/pkg/math/#Sqrt][math.Sqrt]] dans la bibliothèque standard ?

(*Note*:* Si vous êtes intéressé par les détails de l'algorithme, le z² - x ci-dessus
est la distance entre z² et la solution (x), et la division par 2z est la dérivée
de z², pour mettre à l'échelle la façon dont nous ajustons z en fonction de la vitesse à laquelle z² change.
Cette approche générale est appelée [[https://fr.wikipedia.org/wiki/Méthode_de_Newton][méthode de Newton]].
Cela fonctionne bien pour de nombreuses fonctions, mais surtout pour la racine carrée.)

.play flowcontrol/exercise-loops-and-functions.go

* Commutateur (Switch)

Une instruction `switch` est un moyen plus court d'écrire une séquence d'instructions `if`-`else`.
Elle exécute le premier cas dont la valeur est égale à l'expression de condition.

Le commutateur de Go est comme celui de C, C ++, Java, JavaScript et PHP,
sauf que Go n'exécute que le cas sélectionné, pas tous les cas qui suivent.
En effet, l'instruction `break` qui est nécessaire à la fin de chaque cas dans ces
langages est fourni automatiquement dans Go.
Une autre différence importante est que les commutateurs de Go n'ont pas besoin
d'être des constantes et les valeurs impliquées n'ont pas besoin d'être des entiers.

.play flowcontrol/switch.go

* Ordre d'évaluation du commutateur

Le commutateur évalue les cas de haut en bas, en s'arrêtant quand un cas correspond.

(Par exemple,

	switch i {
	case 0:
	case f():
	}

n'appelle pas `f` si `i==0`.)

#appengine: *Note*:* l'heure dans le terrain de jeu de Go semble toujours commencer à
#appengine: 2009-11-10 23:00:00 UTC, une valeur dont la signification est laissée en
#appengine: exercice pour le lecteur.

.play flowcontrol/switch-evaluation-order.go

* Commutateur sans condition

Un commutateur sans condition a la même signification que `switch`true`.

Cette construction permet d'écrire élégamment de longues chaînes if-then-else.

.play flowcontrol/switch-with-no-condition.go

* Defer

Une instruction `defer` diffère l'exécution d'une fonction dès la sortie de la
fonction courante.

Les arguments de l'appel différé sont évalués immédiatement, mais l'appel de fonction
n'est exécuté qu'à la sortie de la fonction courante.

.play flowcontrol/defer.go

* Defers empilés

Les appels de fonction différés sont poussés sur une pile. Quand une fonction se termine, ses
appels différés sont exécutés dans l'ordre dernier entré, premier sorti.

Pour en savoir plus sur les instructions `defer`, consultez cet
[[https://blog.golang.org/defer-panic-and-recover][article de blog]].

.play flowcontrol/defer-multi.go

* Félicitations !

Vous avez terminé cette leçon !

Vous pouvez revenir à la liste des [[/list][modules]] pour trouver ce qu'il faut apprendre à côté, ou continuer avec la [[javascript:click('.next-page')][leçon suivante]].
